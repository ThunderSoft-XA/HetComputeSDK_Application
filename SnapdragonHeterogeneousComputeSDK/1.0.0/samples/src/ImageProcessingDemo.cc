#include <cmath>
#include <fstream>
#include <string.h>
#include <sys/time.h>
#include <hetcompute/hetcompute.hh>　　//1.0.0/include/hetcompute
// header to include the dsp bindings, it is generated by the Hexagon SDK
#include <include/hetcompute_dsp.h>   //3.3.3/examples/common/HetCompute_dsp/android_Debug_aarch64/ship  or /external/dsp/include
#include <hetcompute/gpukernel.hh>    //1.0.0/include/hetcompute

#ifdef __ANDROID__
#define DEFAULT_INPUT_FILE "/mnt/sdcard/SampleGrayImageUncompressed.tga"
#else
#define DEFAULT_INPUT_FILE "SampleGrayImageUncompressed.tga"
#endif // __ANDROID__

#ifdef __ANDROID__
    char const* output_filename_cpu = "/mnt/sdcard/output_image_cpu.tga";
    char const* output_filename_gpu = "/mnt/sdcard/output_image_gpu.tga";
    char const* output_filename_dsp = "/mnt/sdcard/output_image_dsp.tga";
#else
    char const* output_filename_cpu = "output_image_cpu.tga";
    char const* output_filename_gpu = "output_image_gpu.tga";
    char const* output_filename_dsp = "output_image_dsp.tga";
#endif

#define Pixel unsigned char

#define MAX_DIST (255 * 255)
#define SEARCH_WINDOW_SIZE 21
#define SIMILARITY_WINDOW_SIZE 7

struct Point
{
    int x; // the col, width;
    int y; // the row, height
};

// Describes the header structure of uncompressed TGA images.
struct tgaheadertype
{
    unsigned char  _id_length, _color_map_type, _image_type;
    unsigned short _cmap_start, _cmap_length;
    unsigned char  _cmap_depth;
    unsigned short _xOffset, _yOffset, _width, _height;
    unsigned char  _pixel_depth, _image_descriptor;
} __attribute__((packed));

static unsigned char pixel_depth;
static unsigned char image_type;
static unsigned int  img_width;
static unsigned int  img_height;
static unsigned int  input_buffer_size;
static unsigned int  output_buffer_size;
static float*        similarity_weights;

static unsigned long process_calc_time_cpu = 0;
static unsigned long process_calc_time_gpu = 0;
static unsigned long process_calc_time_dsp = 0;
using namespace hetcompute;

long getCurrentTimeMsec();
void compute_intensity_dist_weight_table();
void read_tga(char const* file_name, Pixel*& src);
void write_tga(char const* file_name, Pixel*& data);


Point
clamp_to_reflection(Point p)
{
    p.x = abs(p.x);
    p.y = abs(p.y);
    if (p.x >= img_width)
        p.x = img_width - (p.x - img_width) - 1;
    if (p.y >= img_height)
        p.y = img_height - (p.y - img_height) - 1;
    return p;
}


int
get_neighbor_dist_to_current(Point ref, Point p, Pixel* input)
{
    int area = SIMILARITY_WINDOW_SIZE * SIMILARITY_WINDOW_SIZE;
    Point p_neighbor;
    Point ref_neighbor;
    int   color_dist_sum = 0;
    for (int i = 0; i < SIMILARITY_WINDOW_SIZE; i++)
    {
        for (int j = 0; j < SIMILARITY_WINDOW_SIZE; j++)
        {
            p_neighbor.y   = p.y - SIMILARITY_WINDOW_SIZE / 2 + i;
            p_neighbor.x   = p.x - SIMILARITY_WINDOW_SIZE / 2 + j;
            p_neighbor     = clamp_to_reflection(p_neighbor);
            ref_neighbor.y = ref.y - SIMILARITY_WINDOW_SIZE / 2 + i;
            ref_neighbor.x = ref.x - SIMILARITY_WINDOW_SIZE / 2 + j;
            ref_neighbor   = clamp_to_reflection(ref_neighbor);
            int dist       = input[p_neighbor.y * img_width + p_neighbor.x] - input[ref_neighbor.y * img_width + ref_neighbor.x];
            color_dist_sum += dist * dist;
        }
    }
    color_dist_sum /= area;
    return color_dist_sum;
}


void
compute_weights(Pixel* input, Point point, float* w)
{
    /*
     * Compute similarity using Euclidian distance in the similarity window,
     * using equation above. reads from the input, writes int the array weights.
     */
    for (int i = 0; i < SEARCH_WINDOW_SIZE; i++)
    {
        for (int j = 0; j < SEARCH_WINDOW_SIZE; j++)
        {
            Point neighbor;
            neighbor.x                    = point.x - SEARCH_WINDOW_SIZE / 2 + i;
            neighbor.y                    = point.y - SEARCH_WINDOW_SIZE / 2 + j;
            neighbor                      = clamp_to_reflection(neighbor);
            int dist                      = get_neighbor_dist_to_current(point, neighbor, input);
            w[i * SEARCH_WINDOW_SIZE + j] = similarity_weights[dist];
        }
    }
}


/*
 * Create task for processing each pixel:
 */
void
denoise_image_process_for_cpu(Pixel* input, Pixel* output)
{
    unsigned long begin_process_time = 0;
    unsigned long end_process_time = 0;

    // Create a reusable: w[SEARCH_WINDOW_SIZE][SEARCH_WINDOW_SIZE].
    float w[SEARCH_WINDOW_SIZE * SEARCH_WINDOW_SIZE];

    auto g = hetcompute::create_group("denoise_task_per_pixel");
    // Iterate through all points in the input image
    for (int y = 0; y < img_height; y++)
    {
        for (int x = 0; x < img_width; x++)
        {
            g->launch([x, y, &w, input, &output] {
                // Compute weights for points in the search window.
                compute_weights(input, Point{ x, y }, w);
                float weight_sum = 0;
                float temp       = 0;
                // Denoise: compute the weighted average for this point.
                for (int i = 0; i < SEARCH_WINDOW_SIZE; i++)
                {
                    for (int j = 0; j < SEARCH_WINDOW_SIZE; j++)
                    {
                        Point neighbor;
                        neighbor.x = x - SEARCH_WINDOW_SIZE / 2 + i;
                        neighbor.y = y - SEARCH_WINDOW_SIZE / 2 + j;
                        neighbor   = clamp_to_reflection(neighbor);
                        temp += w[i * SEARCH_WINDOW_SIZE + j] * input[neighbor.y * img_width + neighbor.x];
                        weight_sum += w[i * SEARCH_WINDOW_SIZE + j];
                    }
                }

                temp /= weight_sum;
                output[y * img_width + x] = static_cast<Pixel>(temp);
            });
        }
    }

    begin_process_time = getCurrentTimeMsec();
    g->wait_for(); // wait for all the tasks to complete
    end_process_time = getCurrentTimeMsec();

    process_calc_time_cpu += (end_process_time - begin_process_time);
}


// Create a string containing OpenCL C kernel code.
#define OCL_KERNEL(name, k) std::string const name##_string = #k

OCL_KERNEL(image_kernel, 
           __kernel void process_denoise_image(__global unsigned char* input_buffer, 
                                               __global float* output_buffer, 
                                               __global float* similarity_weights_buffer, 
                                               unsigned int searchWindowSize, 
                                               unsigned int similarityWindowSize, 
                                               unsigned int imgWidth, 
                                               unsigned int imgHeight) {
    unsigned int height = get_global_id(1);
    unsigned int width = get_global_id(0);

    float reusable_buffer[441];

    for (int i = 0; i < searchWindowSize; i++) {
        for (int j = 0; j < searchWindowSize; j++) {
            int2 point = (int2) (width, height);
            int2 neighbor = (int2) (0, 0);

            neighbor.x = point.x - searchWindowSize / 2 + i;
            neighbor.y = point.y - searchWindowSize / 2 + j;

            neighbor.x = abs(neighbor.x);
            neighbor.y = abs(neighbor.y);

            if (neighbor.x >= imgWidth) {
                neighbor.x = imgWidth - (neighbor.x - imgWidth) - 1;
            }

            if (neighbor.y >= imgHeight) {
                neighbor.y = imgHeight - (neighbor.y - imgHeight) - 1;
            }

            int area = similarityWindowSize * similarityWindowSize;
            int color_dist_sum = 0;
            int2 p_neighbor = (int2) (0, 0);
            int2 ref_neighbor = (int2) (0, 0);

            for (int ii = 0; ii < similarityWindowSize; ii++) {
                for (int jj = 0; jj < similarityWindowSize; jj++) {
                    p_neighbor.x = neighbor.x - similarityWindowSize / 2 + jj;
                    p_neighbor.y = neighbor.y - similarityWindowSize / 2 + ii;

                    p_neighbor.x = abs(p_neighbor.x);
                    p_neighbor.y = abs(p_neighbor.y);

                    if (p_neighbor.x >= imgWidth) {
                        p_neighbor.x = imgWidth - (p_neighbor.x - imgWidth) - 1;
                    }

                    if (p_neighbor.y >= imgHeight) {
                        p_neighbor.y = imgHeight - (p_neighbor.y - imgHeight) - 1;
                    }


                    ref_neighbor.x = point.x - similarityWindowSize / 2 + jj;
                    ref_neighbor.y = point.y - similarityWindowSize / 2 + ii;

                    ref_neighbor.x = abs(ref_neighbor.x);
                    ref_neighbor.y = abs(ref_neighbor.y);

                    if (ref_neighbor.x >= imgWidth) {
                        ref_neighbor.x = imgWidth - (ref_neighbor.x - imgWidth) - 1;
                    }

                    if (ref_neighbor.y >= imgHeight) {
                        ref_neighbor.y = imgHeight - (ref_neighbor.y - imgHeight) - 1;
                    }

                    int dist = input_buffer[p_neighbor.y * imgWidth + p_neighbor.x] - input_buffer[ref_neighbor.y * imgWidth + ref_neighbor.x];
                    color_dist_sum += dist * dist;
                }
            }

            color_dist_sum /= area;
            reusable_buffer[i * searchWindowSize + j] = similarity_weights_buffer[color_dist_sum];
        }
    }

    float weight_sum = 0;
    float temp = 0;

    for (int m = 0; m < searchWindowSize; m++) {
        for (int n = 0; n < searchWindowSize; n++) {
            int2 search_neighbor = (int2) (0, 0);
            search_neighbor.x = width - searchWindowSize / 2 + m;
            search_neighbor.y = height - searchWindowSize / 2 + n;

            search_neighbor.x = abs(search_neighbor.x);
            search_neighbor.y = abs(search_neighbor.y);

            if (search_neighbor.x >= imgWidth) {
                search_neighbor.x = imgWidth - (search_neighbor.x - imgWidth) - 1;
            }

            if (search_neighbor.y >= imgHeight) {
                search_neighbor.y = imgHeight - (search_neighbor.y - imgHeight) - 1;
            }

            temp += reusable_buffer[m * searchWindowSize + n] * input_buffer[search_neighbor.y * imgWidth + search_neighbor.x];
            weight_sum += reusable_buffer[m * searchWindowSize + n];
        }
    }

    temp /= weight_sum;
    output_buffer[height * imgWidth + width] = temp;
});

void
denoise_image_process_for_gpu(Pixel* input, Pixel* output)
{
    unsigned long begin_process_time = 0;
    unsigned long end_process_time = 0;

    // create HetComputeSDK buffer
    auto input_buffer = hetcompute::create_buffer<unsigned char>(input_buffer_size, hetcompute::device_set({ hetcompute::gpu }));
    auto output_buffer = hetcompute::create_buffer<float>(output_buffer_size, hetcompute::device_set({ hetcompute::gpu }));
    auto similarity_weights_buffer = hetcompute::create_buffer<float>(MAX_DIST, hetcompute::device_set({ hetcompute::gpu }));

    // Init HetComputeSDK buffer
    input_buffer.acquire_wi();
    similarity_weights_buffer.acquire_wi();
    for (size_t x = 0; x < input_buffer_size; x++) {
        input_buffer[x] = input[x];
    }

    for (size_t y = 0; y < MAX_DIST; y++) {
        similarity_weights_buffer[y] = similarity_weights[y];
    }
    input_buffer.release();
    similarity_weights_buffer.release();

    // create GPU kernel
    auto gk = hetcompute::create_gpu_kernel<hetcompute::buffer_ptr<const unsigned char>, 
                                            hetcompute::buffer_ptr<float>, 
                                            hetcompute::buffer_ptr<const float>, 
                                            const unsigned int, 
                                            const unsigned int, 
                                            const unsigned int, 
                                            const unsigned int>
                                            (image_kernel_string, "process_denoise_image");

    //! [Create a 2D Range Task]
    hetcompute::range<2> range_2d(img_width, img_height);

    // Create a task
    auto gpu_task = hetcompute::create_task(gk, range_2d, input_buffer, output_buffer, 
                                            similarity_weights_buffer, 
                                            SEARCH_WINDOW_SIZE, SIMILARITY_WINDOW_SIZE, 
                                            img_width, img_height);

    // Launch the task on the gpu
    gpu_task->launch();

    // Wait for task completion.
    begin_process_time = getCurrentTimeMsec();
    gpu_task->wait_for();
    end_process_time = getCurrentTimeMsec();

    process_calc_time_gpu += (end_process_time - begin_process_time);

    output_buffer.acquire_ro();
    for (size_t count = 0; count < output_buffer.size(); count++) {
        output[count] = static_cast<Pixel>(output_buffer[count]);
    }
    output_buffer.release();
}


void
denoise_image_process_for_dsp(Pixel* input, Pixel* output)
{
    unsigned long begin_process_time = 0;
    unsigned long end_process_time = 0;

    // create HetComputeSDK buffer
    auto input_buffer = hetcompute::create_buffer<char>(input_buffer_size, hetcompute::device_set({ hetcompute::dsp }));
    auto output_buffer = hetcompute::create_buffer<float>(output_buffer_size, hetcompute::device_set({ hetcompute::dsp }));
    auto similarity_weights_buffer = hetcompute::create_buffer<float>(MAX_DIST, hetcompute::device_set({ hetcompute::dsp }));

    // Init HetComputeSDK buffer
    input_buffer.acquire_wi();
    similarity_weights_buffer.acquire_wi();
    for (size_t x = 0; x < input_buffer_size; x++) {
        input_buffer[x] = static_cast<Pixel>(input[x]);
    }

    for (size_t y = 0; y < MAX_DIST; y++) {
        similarity_weights_buffer[y] = similarity_weights[y];
    }
    input_buffer.release();
    similarity_weights_buffer.release();

    // Create task group
    auto dg = hetcompute::create_group();

    // create DSP kernel
    auto dk = hetcompute::create_dsp_kernel<>(hetcompute_dsp_denoise_image_process);

    // Launch the task on the dsp
    for (int height = 0; height < img_height; height++) {
        for (int width = 0; width < img_width; width++) {
            dg->launch(dk, input_buffer, output_buffer, similarity_weights_buffer, 
                       SEARCH_WINDOW_SIZE, SIMILARITY_WINDOW_SIZE, 
                       img_width, img_height, width, height);
        }
    }

    begin_process_time = getCurrentTimeMsec();
    dg->wait_for();
    end_process_time = getCurrentTimeMsec();

    process_calc_time_dsp += (end_process_time - begin_process_time);

    output_buffer.acquire_ro();
    for (size_t count = 0; count < output_buffer.size(); count++) {
        output[count] = static_cast<Pixel>(output_buffer[count]);
    }
    output_buffer.release();
}

int
main(int argc, char *argv[])
{
    hetcompute::runtime::init();

    // This is to ensure all buffers are deleted before we call shutdown.
    {
        const char* inputfile;

        if (argc != 1) {
            HETCOMPUTE_ILOG("******************************************************************************************");
            HETCOMPUTE_ILOG("Application don't need to input parameter.");
            HETCOMPUTE_ILOG("eg: ./hetcompute_sample_ImageProcessingDemo");
            HETCOMPUTE_ILOG("******************************************************************************************");

            return -1;
        } else {
            inputfile = DEFAULT_INPUT_FILE;
        }

        // Load image file
        Pixel* input_img_data = nullptr;
        read_tga(inputfile, input_img_data);                           //函数调用
        output_buffer_size = img_width * img_height * sizeof(Pixel);
        Pixel* output_img_data = new Pixel[output_buffer_size];

        // Begin process image
        // Create a table for note dist weight
        compute_intensity_dist_weight_table();                          //! == !

        // Begin cpu process
        memset(output_img_data, 0, output_buffer_size);
        denoise_image_process_for_cpu(input_img_data, output_img_data);
        write_tga(output_filename_cpu, output_img_data);
        HETCOMPUTE_ILOG("denoise_image_cpu Completed.");


        // Begin gpu process
        memset(output_img_data, 0, output_buffer_size);
        denoise_image_process_for_gpu(input_img_data, output_img_data);
        write_tga(output_filename_gpu, output_img_data);
        HETCOMPUTE_ILOG("denoise_image_gpu Completed.");

        // Begin dsp process
        memset(output_img_data, 0, output_buffer_size);
        denoise_image_process_for_dsp(input_img_data, output_img_data);
        write_tga(output_filename_dsp, output_img_data);
        HETCOMPUTE_ILOG("denoise_image_dsp Completed.");

        delete [] input_img_data;
        delete [] output_img_data;
        delete [] similarity_weights;
        HETCOMPUTE_ILOG("******CPU -- Running CPU proccess image total time is: %ld ms", process_calc_time_cpu);
        HETCOMPUTE_ILOG("@@@@@@GPU -- Running GPU proccess image total time is: %ld ms", process_calc_time_gpu);
        HETCOMPUTE_ILOG("&&&&&&DSP -- Running DSP proccess image total time is: %ld ms", process_calc_time_dsp);
    }

    
    hetcompute::runtime::shutdown();
    return 0;
}

long
getCurrentTimeMsec()
{
    long msec = 0;
    char str[20] = {0};
    struct timeval stuCurrentTime;

    gettimeofday(&stuCurrentTime, NULL);
    sprintf(str, "%ld%03ld", stuCurrentTime.tv_sec, (stuCurrentTime.tv_usec) / 1000);

    for (int i = 0; i < strlen(str); i++) {
        msec = msec * 10 + (str[i] - '0');
    }

    return msec;
}

void
compute_intensity_dist_weight_table()
{
    similarity_weights = new float[MAX_DIST];
    const double WEIGHT_THRESHOLD = 0.001;
    float h = 15.0f;

    for (int dist = 0; dist < MAX_DIST; dist++)
    {
        float w = std::exp(-dist / (h * h));
        if (w < WEIGHT_THRESHOLD)
            w = 0;

        similarity_weights[dist] = w;
    }
}

void
read_tga(char const* file_name, Pixel*& src)
{
    std::ifstream tga(file_name, std::ios::binary);
    if (!tga.is_open())
    {
        HETCOMPUTE_FATAL("Could not open src image file: %s", file_name);
    }
    tgaheadertype tga_header;
    tga.read(reinterpret_cast<char*>(&tga_header), sizeof(tga_header));
    img_width  = tga_header._width;
    img_height = tga_header._height;

    pixel_depth = tga_header._pixel_depth;
    image_type  = tga_header._image_type;
    HETCOMPUTE_ILOG("image format: %d, pixel depth: %d, width: %d, height: %d\n",
                    int(tga_header._image_type),
                    int(tga_header._pixel_depth),
                    int(img_width),
                    int(img_height));

    if (pixel_depth != 8)
        HETCOMPUTE_FATAL("PROCESSING GRAY IMAGE WITH DEPTH OF 1 BYTE ONLY\n");

    int bytes_per_pixel = int(tga_header._pixel_depth) / 8;
    input_buffer_size = img_width * img_height * bytes_per_pixel * sizeof(Pixel);
    src = new Pixel[input_buffer_size];
    tga.read(reinterpret_cast<char*>(src), img_width * img_height * bytes_per_pixel * sizeof(Pixel));
}

void
write_tga(char const* file_name, Pixel*& data)
{
    tgaheadertype tga_header;
    HETCOMPUTE_ILOG("tga header size: %d\n", int(sizeof(tga_header)));
    memset(&tga_header, 0, sizeof(tga_header));
    tga_header._image_type  = image_type;
    tga_header._width       = img_width;
    tga_header._height      = img_height;
    tga_header._pixel_depth = pixel_depth; // grey image 8

    std::ofstream tga(file_name, std::ios::binary);
    if (!tga.is_open())
    {
        HETCOMPUTE_FATAL("Could not open output image file: %s", file_name);
    }

    tga.write(reinterpret_cast<char*>(&tga_header), sizeof(tga_header));
    tga.write(reinterpret_cast<char*>(data), img_width * img_height * sizeof(Pixel));
}