#include <pthread.h>
#include <algorithm>
#include <random>
#include <string.h>
#include <sys/time.h>
#include <hetcompute/hetcompute.hh>
// header to include the dsp bindings, it is generated by the Hexagon SDK
#include <include/hetcompute_dsp.h>
#include <hetcompute/gpukernel.hh>

static int array_size = 0;
static int loop_number = 0;
static int work_method = 0;

static bool thread_flag_cpu = false;
static bool thread_flag_gpu = false;
static bool thread_flag_dsp = false;

static unsigned long process_calc_time_cpu = 0;
static unsigned long process_calc_time_gpu = 0;
static unsigned long process_calc_time_dsp = 0;

static unsigned int arrayDivisor = 0;

pthread_mutex_t mutex_lock;

long getCurrentTimeMsec()
{
    long msec = 0;
    char str[20] = {0};
    struct timeval stuCurrentTime;

    gettimeofday(&stuCurrentTime, NULL);
    sprintf(str, "%ld%03ld", stuCurrentTime.tv_sec, (stuCurrentTime.tv_usec) / 1000);

    for (int i = 0; i < strlen(str); i++) {
        msec = msec * 10 + (str[i] - '0');
    }

    return msec;
}


void run_CPU(hetcompute::buffer_ptr<const int> matrixA,  
             hetcompute::buffer_ptr<int> matrixB)
{
    unsigned long begin_process_time = 0;
    unsigned long end_process_time = 0;
    int arrayLen = matrixA.size();

    int* input_data = new int[arrayLen * sizeof(int)];
    int* output_data = new int[arrayLen * sizeof(int)];

    matrixA.acquire_ro();
    for (size_t index = 0; index < arrayLen; index++) {
        input_data[index] = matrixA[index];
    }
    matrixA.release();
    // The CPU kernel infers the access directions
    auto cg = hetcompute::create_group("Calculate array value");

    for (size_t x = 0; x < loop_number; x++) {
        // create a CPU parallel calc by HetComputeSDK
        cg->launch([arrayLen, input_data, &output_data] {
            for (size_t y = 0; y < arrayLen; y++) {
                // matrix addition
                output_data[y] = input_data[y] + input_data[y];
                // matrix multiplication
                output_data[y] = input_data[y] * input_data[y];
            }
        });
    }

    begin_process_time = getCurrentTimeMsec();
    cg->wait_for();
    end_process_time = getCurrentTimeMsec();
    process_calc_time_cpu += (end_process_time - begin_process_time);

    /*// print matrixB
    matrixB.acquire_ro();
    for (size_t count = 0; count < matrixB.size(); count++) {
        HETCOMPUTE_ILOG("******CPU -- This is a show value. matrixB[%zu]=%d", count, matrixB[count]);
    }
    matrixB.release();*/

    delete [] input_data;
    delete [] output_data;
}


// Create a string containing OpenCL C kernel code.
#define OCL_KERNEL(name, k) std::string const name##_string = #k

OCL_KERNEL(matrix_kernel, __kernel void user_function_gpu(__global int* A, __global int* B) {
    unsigned int loopCount = get_global_id(1);
    unsigned int arrayCount = get_global_id(0);

    B[arrayCount] = A[arrayCount] + A[arrayCount];
    B[arrayCount] = A[arrayCount] * A[arrayCount];
});

void run_GPU(hetcompute::buffer_ptr<const int> matrixA, 
             hetcompute::buffer_ptr<int> matrixB)
{
    unsigned long begin_process_time = 0;
    unsigned long end_process_time = 0;

    // create GPU kernel
    auto gk = hetcompute::create_gpu_kernel<hetcompute::buffer_ptr<const int>, 
                                            hetcompute::buffer_ptr<int>> 
                                            (matrix_kernel_string, "user_function_gpu");

    // launch GPU kernel over 2D range
    auto t = hetcompute::launch(gk, hetcompute::range<2>(matrixB.size(), loop_number), matrixA, matrixB);

    begin_process_time = getCurrentTimeMsec();
    t->wait_for();
    end_process_time = getCurrentTimeMsec();

    process_calc_time_gpu += (end_process_time - begin_process_time);

    /*// print matrixB
    matrixB.acquire_ro();
    for (size_t count = 0; count < matrixB.size(); count++) {
        HETCOMPUTE_ILOG("@@@@@@GPU -- This is a show value. matrixB[%zu]=%d", count, matrixB[count]);
    }
    matrixB.release();*/
}


void run_DSP(hetcompute::buffer_ptr<const int> matrixA, 
             hetcompute::buffer_ptr<int> matrixB)
{
    unsigned long begin_process_time = 0;
    unsigned long end_process_time = 0;

    auto dg = hetcompute::create_group();
    auto dk = hetcompute::create_dsp_kernel<>(hetcompute_dsp_matrix_buffer);

    for (size_t x = 0; x < loop_number; x++) {
        dg->launch(dk, matrixA, matrixB);
    }

    begin_process_time = getCurrentTimeMsec();
    dg->wait_for();
    end_process_time = getCurrentTimeMsec();

    process_calc_time_dsp += (end_process_time - begin_process_time);

    /*// print matrixB
    matrixB.acquire_ro();
    for (size_t count = 0; count < matrixB.size(); count++) {
        HETCOMPUTE_ILOG("&&&&&&DSP -- This is a show value. matrixB[%zu]=%d", count, matrixB[count]);
    }
    matrixB.release();*/
}


// function for processor thread
// CPU thread
static void* cpu_pthread(void *arg)
{
    unsigned int* tmp = (unsigned int*)arg;

    auto A = hetcompute::create_buffer<int>(arrayDivisor, hetcompute::device_set({ hetcompute::cpu }));
    auto B = hetcompute::create_buffer<int>(arrayDivisor, hetcompute::device_set({ hetcompute::cpu }));
    // initialize the input array
    A.acquire_wi();
    for (size_t count = 0; count < arrayDivisor; count++) {
        A[count] = tmp[count];
    }
    A.release();

    pthread_mutex_lock(&mutex_lock);
    run_CPU(A, B);
    pthread_mutex_unlock(&mutex_lock);

    thread_flag_cpu = true;
    return 0;
}


// GPU thread
static void* gpu_pthread(void *arg)
{
    unsigned int* tmp = (unsigned int*)arg;

    auto A = hetcompute::create_buffer<int>(arrayDivisor, hetcompute::device_set({ hetcompute::gpu }));
    auto B = hetcompute::create_buffer<int>(arrayDivisor, hetcompute::device_set({ hetcompute::gpu }));
    // initialize the input array
    A.acquire_wi();
    for (size_t count = arrayDivisor; count < (2 * arrayDivisor); count++) {
        A[count - arrayDivisor] = tmp[count];
    }
    A.release();

    pthread_mutex_lock(&mutex_lock);
    run_GPU(A, B);
    pthread_mutex_unlock(&mutex_lock);

    thread_flag_gpu = true;
    return 0;
}


// DSP thread
static void* dsp_pthread(void *arg)
{
    unsigned int* tmp = (unsigned int*)arg;

    auto A = hetcompute::create_buffer<int>((array_size - (2 * arrayDivisor)), hetcompute::device_set({ hetcompute::dsp }));
    auto B = hetcompute::create_buffer<int>((array_size - (2 * arrayDivisor)), hetcompute::device_set({ hetcompute::dsp }));
    // initialize the input array
    A.acquire_wi();
    for (size_t count = 2 * arrayDivisor; count < array_size; count++) {
        A[count - (2 * arrayDivisor)] = tmp[count];
    }
    A.release();

    pthread_mutex_lock(&mutex_lock);
    run_DSP(A, B);
    pthread_mutex_unlock(&mutex_lock);

    thread_flag_dsp = true;
    return 0;
}


int
main(int argc, char *argv[])
{
    hetcompute::runtime::init();

    // This is to ensure all buffers are deleted before we call shutdown.
    {
        if (argc != 4) {
            HETCOMPUTE_ILOG("******************************************************************************************");
            HETCOMPUTE_ILOG("Input parameters number is wrong. Please input right parameter");
            HETCOMPUTE_ILOG("eg: ./hetcompute_sample_MatrixAlgorithmDemo array_size loop_number work_method");
            HETCOMPUTE_ILOG("eg: array_size: is create buffer size.");
            HETCOMPUTE_ILOG("eg: loop_number: is Number of cycles calculated work_method");
            HETCOMPUTE_ILOG("eg: work_method: is processor method. 1 is serial(cpu->gpu->dsp). 2 is parallel(cpu&gpu&dsp)");
            HETCOMPUTE_ILOG("./hetcompute_sample_MatrixAlgorithmDemo 1000 20 1");
            HETCOMPUTE_ILOG("******************************************************************************************");

            return -1;
        }

        array_size = atoi(argv[1]);
        if (array_size < 3) {
            HETCOMPUTE_ILOG("Input array_size < 3 is wrong. Please re-input array_size. array_size => 3");
            return -1;
        }

        loop_number = atoi(argv[2]);
        if (loop_number <= 0) {
            HETCOMPUTE_ILOG("Input loop_number <= 0 is wrong. Please re-input loop_number. loop_number > 0");
            return -1;
        }

        work_method = atoi(argv[3]);
        if (work_method <= 0) {
            HETCOMPUTE_ILOG("Input work_method <= 0 is wrong. Please re-input work_method. 1 or 2");
            return -1;
        }

        // create the buffers including the devices that will use them
        auto A = hetcompute::create_buffer<int>(array_size, hetcompute::device_set({ hetcompute::dsp, hetcompute::cpu, hetcompute::gpu }));

        // initialize the input array with random numbers
        std::random_device              random_device;
        std::mt19937                    generator(random_device());
        const int                       min_value = 0, max_value = 2019;
        std::uniform_int_distribution<> dist(min_value, max_value);
        auto                            gen_dist = std::bind(dist, std::ref(generator));

        A.acquire_wi();                                                      //!
        std::generate(A.begin(), A.end(), gen_dist);
        A.release();                                                         //!

        // ADDITION 1 ; MULTIPLICATION 2
        // Begin CPU process matrix []
        if (work_method == 1) {
            HETCOMPUTE_ILOG("******************************************************************************************");
            HETCOMPUTE_ILOG("We will create a in_buffer[%d], Program will init random value to buffer.", array_size);
            HETCOMPUTE_ILOG("CPU->GPU->DSP will running a calculate and recipe runnig %d times.", loop_number);
            HETCOMPUTE_ILOG("out_buffer = in_buffer[i] + in_buffer[i] and out_buffer = in_buffer[i] * in_buffer[i].");
            HETCOMPUTE_ILOG("******************************************************************************************");

            auto B = hetcompute::create_buffer<int>(array_size, hetcompute::device_set({ hetcompute::dsp, hetcompute::cpu, hetcompute::gpu }));

            // Begin CPU process matrix []
            run_CPU(A, B);

            // Begin GPU process matrix []
            run_GPU(A, B);

            // Begin DSP process matrix []
            run_DSP(A, B);

            HETCOMPUTE_ILOG("Show all processors serial calc time:");
        } else if (work_method == 2) {
            pthread_t cpu_thread = 0;
            pthread_t gpu_thread = 0;
            pthread_t dsp_thread = 0;

            // Init thread mute
            pthread_mutex_init(&mutex_lock,NULL);

            // split array to 3 array for cpu, gpu, dsp
            arrayDivisor = array_size / 3;
            unsigned int* array_buffer = new unsigned int[array_size * sizeof(unsigned int)];

            HETCOMPUTE_ILOG("******************************************************************************************");
            HETCOMPUTE_ILOG("We will create a in_buffer[%d] and init random value. Then split it to 3 array.", array_size);
            HETCOMPUTE_ILOG("cpu_buffer[0 to %d], gpu_buffer[%d to %d], dsp_buffer[%d to %d], ", 
                            arrayDivisor - 1, arrayDivisor, ((2 * arrayDivisor) - 1), (2 * arrayDivisor), array_size - 1);
            HETCOMPUTE_ILOG("CPU & GPU & DSP will running a calculate and recipe runnig %d times.", loop_number);
            HETCOMPUTE_ILOG("out_buffer = in_buffer[i] + in_buffer[i] and out_buffer = in_buffer[i] * in_buffer[i].");
            HETCOMPUTE_ILOG("******************************************************************************************");

            // lock the mute for wait create all thread.
            pthread_mutex_lock(&mutex_lock);
            for (size_t count = 0; count < array_size; count++) {
                array_buffer[count] = A[count];
            }

            // create cpu, gpu, dsp thread.
            if (pthread_create(&cpu_thread, NULL, cpu_pthread, (void*)array_buffer)) {
                HETCOMPUTE_ILOG("error - can't create cpu thread.");
                goto exit;
            }

            if (pthread_create(&gpu_thread, NULL, gpu_pthread, (void*)array_buffer)) {
                HETCOMPUTE_ILOG("error - can't create cpu thread.");
                goto exit;
            }

            if (pthread_create(&dsp_thread, NULL, dsp_pthread, (void*)array_buffer)) {
                HETCOMPUTE_ILOG("error - can't create cpu thread.");
                goto exit;
            }

            // unlock main thread mute.
            pthread_mutex_unlock(&mutex_lock);

            do
            {
                // delay 1ms for subthread
                usleep(200);

                // check thread status if it has finish.
                if (thread_flag_cpu && 
                    thread_flag_gpu && 
                    thread_flag_dsp) {
                    break;
                }
            } while (true);

            delete [] array_buffer;
        } else {
            HETCOMPUTE_ILOG("WARNING: Input processor method is wrong. Please re-input 1 or 2.");
            goto exit;
        }

        HETCOMPUTE_ILOG("******CPU -- Running CPU calc addition and multiplication %d times and total time is: %ld ms", loop_number, process_calc_time_cpu);
        HETCOMPUTE_ILOG("@@@@@@GPU -- Running GPU calc addition and multiplication %d times and total time is: %ld ms", loop_number, process_calc_time_gpu);
        HETCOMPUTE_ILOG("&&&&&&DSP -- Running DSP calc addition and multiplication %d times and total time is: %ld ms", loop_number, process_calc_time_dsp);
    }

exit:
    hetcompute::runtime::shutdown();
    return 0;
}
